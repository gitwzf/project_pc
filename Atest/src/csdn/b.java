package csdn;

public class b {
	/**
	 * 在n*m的01矩阵中，如果一块连通的1中任何两个1的最小距离等于他们下标的距离减一，那么这个全1连通块就是合法的。现在给你一个01矩阵，
	 * 请你计算出将它的所有全1连通块都变成合法的所需改变的最少的0的个数
	 * （将0变成1）。两个元素的最小距离就是一个元素在连通块里走到另一个元素所经过的最少的元素的个数
	 * （不包括这两个元素），下标的距离就是abs(x1-x2)+abs(y1-y2). 例如：0111110
	 * 在这个矩阵中11111就是一个连通块，最左边的1到最右边的1的距离就是3，他们下标的距离是4。 输入描述：
	 * 输入包含多组测试数据，每组测试数据包含n+1行，第一行为一个正整数n，m(0<n,m<=50));接下来就是n*m的01矩阵。 输出描述：
	 * 输出包含一个数就是改变最少的0的个数。 挑战规则： 输入样例： 3 3 100 101 111 3 3 111 101 101 输出样例： 1 2
	 * 按照通过题目的答案代码的完整性，高效性，可实现性来评比结果。
	 **/
    public static void main(String[] args) {
    }
}
